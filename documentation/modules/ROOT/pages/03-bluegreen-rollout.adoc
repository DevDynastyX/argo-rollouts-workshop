= Blue-Green Rollout
include::_attributes.adoc[]

[#blue-green-overview]
== Blue-Green Overview

In a blue-green deployment we deploy a new version of the application in a separate stack from the current version with
the two versions running in parallel for a period of time. This enables testing on the new version while users continue
to access the current version of the application until a cut-over of traffic happens.

The diagram below shows this process over time.

image::overview-blue-green.png[]

In traditional infrastructure this approach can very challenging and while Kubernetes is simpler due to it's declarative nature the process still tends to be cumbersome to manage since bespoke automation needs to be created to manage the separate stacks,
testing and traffic management between versions.

This is where Argo Rollouts comes in, it greatly reduces the complexity by providing these capabilities with a simple, declarative approach. In this module
we will deploy a simple blue-green Rollout and explore it's basic capabilities.

[#deploy-blue-green-rollout]
== Deploy Blue-Green Rollout

Here we will deploy the blue-green rollout in the `user%USERNUM%-prod` namespace following the same process that we did for the Deployment in the previous module. Prior to starting,
confirm you are still at the correct path.

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
cd ~/argo-rollouts-workshop/documentation/modules/ROOT/examples/
----

Next, let's explore the manifests that we will be deploying in the `./bluegreen/base` folder:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
ls ./bluegreen/base
----

Notice that this time we have files for `rollout.yaml`, `services.yaml` and `routes.yaml` which represent our Rollout, Services and Routes. We also have
`kustomization.yaml` as per the last module.

.link:https://github.com/OpenShiftDemos/argo-rollouts-workshop/blob/main/documentation/modules/ROOT/examples/bluegreen/base/rollout.yaml[./bluegreen/base/rollout.yaml,window='_blank']
[source,yaml,subs="+macros,attributes+"]
----
include::ROOT:example$bluegreen/base/rollout.yaml[]
----

Notice that the structure of the Rollout is quite similar to the Deployment, it still uses the standard
Kubernetes .link:https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates[PodTemplate,window='_blank'] but some additional options are available.

.link:https://github.com/OpenShiftDemos/argo-rollouts-workshop/blob/main/documentation/modules/ROOT/examples/bluegreen/base/services.yaml[./bluegreen/base/services.yaml,window='_blank']
[source,yaml,subs="+macros,attributes+"]
----
include::ROOT:example$bluegreen/base/services.yaml[]
----

In the services we define two services, an active service and a preview service. The active service is the service that users of the application will be
interacting with, the preview service would be used to access the new version of the application for testing purposes. As per the .link:https://argo-rollouts.readthedocs.io/en/stable/features/bluegreen/#overview[documentation,window='_blank'],
Argo Rollouts automatically manages the traffic between the services by managing the `.spec.selector`.

A detailed breakdown of the process is also provided in the Argo Rollout documentation .link:https://argo-rollouts.readthedocs.io/en/stable/features/bluegreen/#sequence-of-events[here, window='_blank'].

.link:https://github.com/OpenShiftDemos/argo-rollouts-workshop/blob/main/documentation/modules/ROOT/examples/bluegreen/base/routes.yaml[./bluegreen/base/routes.yaml,window='_blank']
[source,yaml,subs="+macros,attributes+"]
----
include::ROOT:example$bluegreen/base/routes.yaml[]
----

Finally we have two Route objects for active and preview with each tied to their respective service.

To deploy the blue-green rollout, use the following command to process the kustomization:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
oc apply -k ./bluegreen/base -n user%USERNUM%-prod
----

Once you have run the command we can confirm that the rollout has deployed successfully. Use the following command to ensure
that the pods are up and running:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
oc get pods -n user%USERNUM%-prod
----

The console should return something along the lines of

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
NAME                             READY   STATUS    RESTARTS   AGE
rollouts-demo-785c8b55cb-m5mzg   1/1     Running   0          6m51s
rollouts-demo-785c8b55cb-trvsd   1/1     Running   0          6m51s
----

There are two pods since the Rollout specified two replicas.

Next Open the Route for this application. It's in the `user%USERNUM%-dev1` Project.

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
oc get route -n user%USERNUM%-dev rollouts-demo -o jsonpath='{"http://"}{.spec.host}{"\n"}'
----
