= Workshop Overview
include::_attributes.adoc[]

[#workshop-layout]
== Workshop Layout

In this workshop each user will have access to three OpenShift Projects, i.e. namespaces, as follows:

* _user%USERNUM%-dev_. This represents the development environment where we will deploy the application as a vanilla Kubernetes Deployment so
we can compare and contrast it to Rollouts.
* _user%USERNUM%-prod_. This is our production environment, here we will deploy a Rollout for the application. During the course of the workshop
you will deploy rollouts using different strategies and analysis.
* _user%USERNUM%-tools_. This is where the CI/CD tooling is located, it contains a pipeline to promote image changes across the development and production
environments. For this workshop we will be using the integrated OpenShift Pipelines feature, this is not core to the workshop but simply provides an easy
way to manage image changes.

[#review-rollout-manager]
== Review RolloutManager Deployment

The OpenShift GitOps Operator simplifies the deployment and management of Argo Rollouts in an OpenShift cluster.

To deploy Argo Rollouts using the operator we need to define and create a RolloutManager
custom resource in the namespace where we want to run the Rollout. In the case of our workshop a
RolloutManager has already been provisioned for you.

[NOTE]
Argo Rollouts can be deployed as ether a namespace or cluster scope, the OpenShift GitOps operator
currently only supports namespace scope.

To review the rollout manager, execute the following command:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
oc get rolloutmanager argo-rollout -n user%USERNUM%-prod | oc neat
----

[NOTE]
We are using a kubectl plugin called kubectl-neat in order to tidy the yaml by removing
additional fields, labels and annotations added automatically by Kubernetes.

This will return a simple object as follows:

[source,yaml]
---
apiVersion: argoproj.io/v1alpha1
kind: RolloutManager
metadata:
  name: argo-rollout
  namespace: user%USERNUM%-prod
spec: {}
---

As shown here this is a simple declaration which in turn results in the Operator creating
a simple deployment with the Argo Rollout controller monitoring the `user%USERNUM%-prod` for
`Rollout` resources.

[#deploy-application]
== Deploy Application

In order to proceed with this workshop we will need to deploy the application into the development
and production namespaces. The application that we will be deploying is the https://github.com/argoproj/rollouts-demo[Argo Rollouts Demo]
application that displays colored squares.

image::rollouts-demo-app.png[]

Each time we need to deploy the application we will select a version of the application with a different color,
this will enable use to visually see how the application is progressing.

=== Clone the Repository

You need to clone the repository into your web terminal because you will need to
make very small changes to some of the files for the examples:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
git clone https://github.com/OpenShiftDemos/argo-rollouts-workshop ~/argo-rollouts-workshop
----

All of the code used in this workshop will be located in:

`~/argo-rollouts-workshop/code`

[IMPORTANT]
====
The web terminal only supports ephemeral storage. If you shut it down, or if it
times out, any local filesystem changes made will be lost. This means you would
need to clone the repository again. The web terminal is intended for
troubleshooting and simple interaction, and not as a long-lived remote execution
environment. For that, something like
https://developers.redhat.com/products/openshift-dev-spaces/overview[OpenShift
DevSpaces] is a better choice.
====

=== Deploy Development

In the development environment we will be deploying the application as a basic
Kubernetes Deployment so that we can compare and contrast the behavior with Argo Rollouts.

To view the code that we will be using, examine the code in `code/deploy/base`:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
ls code/deploy/base
----

You should see that there are four files in this directory. The `deploy.yaml`, `service.yaml`
and `route.yaml` represent the Deployment, Service and OpenShift route for the application.

[NOTE]
Routes are the way ingress is managed in OpenShift. Routes pre-date Kubernetes Ingress and
while OpenShift supports both Routes retain some additional capabilities and features not yet available
in Ingress hence their continued usage.

There is a fourth file called `kustomization.yaml`, this file is used by the https://kustomize.io[Kustomize] tool and enables
the management of Kubernetes manifests. Kustomize and Helm are the two most popular yaml management tools
in GitOps and we use kustomize here to simplify our deployments.

To deploy the application in Development, run the following command in the terminal:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
oc apply -k code/deploy/base -n user%USERNUM%-dev
----

Once you run the command check the OpenShift console to confirm the deployment occurred successfully.

TODO - More verbiage here how to check this and testing the application
